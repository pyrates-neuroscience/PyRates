
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pyrates.backend.computegraph &#8212; PyRates 0.7.1 documentation</title>
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for pyrates.backend.computegraph</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1"># PyRates software framework for flexible implementation of neural</span>
<span class="c1"># network model_templates and simulations. See also:</span>
<span class="c1"># https://github.com/pyrates-neuroscience/PyRates</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2017-2018 the original authors (Richard Gast and</span>
<span class="c1"># Daniel Rose), the Max-Planck-Institute for Human Cognitive Brain</span>
<span class="c1"># Sciences (&quot;MPI CBS&quot;) and contributors</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;</span>
<span class="c1">#</span>
<span class="c1"># CITATION:</span>
<span class="c1">#</span>
<span class="c1"># Richard Gast and Daniel Rose et. al. in preparation</span>

<span class="sd">&quot;&quot;&quot;This module provides the backend class that should be used to set up any backend in pyrates.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># external imports</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">from</span> <span class="nn">pandas</span> <span class="k">import</span> <span class="n">DataFrame</span><span class="p">,</span> <span class="n">MultiIndex</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">networkx</span> <span class="k">import</span> <span class="n">find_cycle</span><span class="p">,</span> <span class="n">NetworkXNoCycle</span><span class="p">,</span> <span class="n">DiGraph</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="k">import</span> <span class="n">filterwarnings</span>

<span class="c1"># pyrates imports</span>
<span class="kn">from</span> <span class="nn">pyrates.backend.parser</span> <span class="k">import</span> <span class="n">parse_equation_list</span><span class="p">,</span> <span class="n">parse_dict</span>
<span class="kn">from</span> <span class="nn">pyrates</span> <span class="k">import</span> <span class="n">PyRatesException</span>
<span class="kn">from</span> <span class="nn">pyrates.ir.circuit</span> <span class="k">import</span> <span class="n">CircuitIR</span>
<span class="kn">from</span> <span class="nn">pyrates.frontend</span> <span class="k">import</span> <span class="n">CircuitTemplate</span>

<span class="c1"># meta infos</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Richard Gast&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;development&quot;</span>


<div class="viewcode-block" id="ComputeGraph"><a class="viewcode-back" href="../../../pyrates.backend.html#pyrates.backend.computegraph.ComputeGraph">[docs]</a><span class="k">class</span> <span class="nc">ComputeGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Creates a compute graph that contains all nodes in the network plus their recurrent connections.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    net_config</span>
<span class="sd">        Intermediate representation of the network configuration. For a more detailed description, see the documentation</span>
<span class="sd">        of `pyrates.IR.CircuitIR`.</span>
<span class="sd">    dt</span>
<span class="sd">        Step-size with which the network should be simulated later on.</span>
<span class="sd">        Important for discretizing delays, differential equations, ...</span>
<span class="sd">    vectorization</span>
<span class="sd">        Defines the mode of automatic parallelization optimization that should be used. Can be `nodes` for lumping all</span>
<span class="sd">        nodes together in a vector, `full` for full vectorization of the network, or `None` for no vectorization.</span>
<span class="sd">    name</span>
<span class="sd">        Name of the network.</span>
<span class="sd">    build_in_place</span>
<span class="sd">        If False, a copy of the `net_config``will be made before compute graph creation. Should be used, if the</span>
<span class="sd">        `net_config` will be re-used for multiple compute graphs.</span>
<span class="sd">    backend</span>
<span class="sd">        Backend in which to build the compute graph.</span>
<span class="sd">    solver</span>
<span class="sd">        Numerical solver to use for differential equations.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">net_config</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">CircuitIR</span><span class="p">],</span>
                 <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">,</span>
                 <span class="n">vectorization</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
                 <span class="n">name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;net0&#39;</span><span class="p">,</span>
                 <span class="n">build_in_place</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span><span class="p">,</span>
                 <span class="n">solver</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;euler&#39;</span><span class="p">,</span>
                 <span class="n">float_precision</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;float32&#39;</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Instantiates operator.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c1"># set basic attributes</span>
        <span class="c1">######################</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span> <span class="o">=</span> <span class="n">float_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">net_config</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="n">net_config</span> <span class="o">=</span> <span class="n">CircuitTemplate</span><span class="o">.</span><span class="n">from_yaml</span><span class="p">(</span><span class="n">net_config</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">()</span>
        <span class="n">net_config</span> <span class="o">=</span> <span class="n">net_config</span><span class="o">.</span><span class="n">move_edge_operators_to_nodes</span><span class="p">(</span><span class="n">copy_data</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># instantiate the backend and set the backend default_device</span>
        <span class="k">if</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;tensorflow&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.tensorflow_backend</span> <span class="k">import</span> <span class="n">TensorflowBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">TensorflowBackend</span>
        <span class="k">elif</span> <span class="n">backend</span> <span class="o">==</span> <span class="s1">&#39;numpy&#39;</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">.numpy_backend</span> <span class="k">import</span> <span class="n">NumpyBackend</span>
            <span class="n">backend</span> <span class="o">=</span> <span class="n">NumpyBackend</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Invalid backend type: </span><span class="si">{backend}</span><span class="s1">. See documentation for supported backends.&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;float_default_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span> <span class="o">=</span> <span class="n">backend</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span> <span class="o">=</span> <span class="n">solver</span>

        <span class="c1"># pre-process the network configuration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_consistency_check</span><span class="p">(</span><span class="n">net_config</span><span class="p">)</span> <span class="k">if</span> <span class="n">build_in_place</span> \
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_consistency_check</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">net_config</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize</span><span class="p">(</span><span class="n">vectorization_mode</span><span class="o">=</span><span class="n">vectorization</span><span class="p">)</span>

        <span class="c1"># set time constant of the network</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span> <span class="o">=</span> <span class="n">parse_dict</span><span class="p">({</span><span class="s1">&#39;dt&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(),</span>
                                      <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">}},</span>
                              <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">)[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span>

        <span class="c1"># parse node operations</span>
        <span class="c1">#######################</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;building the compute graph...&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">node_updates</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">bottom_layer</span><span class="p">()</span>
            <span class="n">op_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span>

            <span class="c1"># check operators for cyclic relationships</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">find_cycle</span><span class="p">(</span><span class="n">op_graph</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">NetworkXNoCycle</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">PyRatesException</span><span class="p">(</span><span class="s2">&quot;Found cyclic operator graph. &quot;</span>
                                       <span class="s2">&quot;Cycles are not allowed for operators within one node.&quot;</span><span class="p">)</span>

            <span class="n">graph</span> <span class="o">=</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># type: DiGraph</span>

            <span class="c1"># first, parse operators that have no dependencies on other operators</span>
            <span class="c1"># noinspection PyTypeChecker</span>
            <span class="n">primary_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">node_updates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_ops</span><span class="p">(</span><span class="n">primary_ops</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="n">node_name</span><span class="p">,</span> <span class="n">primary_ops</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">next_layer</span><span class="p">()</span>

            <span class="c1"># remove parsed operators from graph</span>
            <span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">primary_ops</span><span class="p">)</span>

            <span class="c1"># now, pass all other operators on the node</span>
            <span class="k">while</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

                <span class="c1"># get all operators that have no dependencies on other operators</span>
                <span class="c1"># noinspection PyTypeChecker</span>
                <span class="n">secondary_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">node_updates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_ops</span><span class="p">(</span><span class="n">secondary_ops</span><span class="p">,</span> <span class="n">node_name</span><span class="o">=</span><span class="n">node_name</span><span class="p">,</span> <span class="n">primary_ops</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">next_layer</span><span class="p">()</span>

                <span class="c1"># remove parsed operators from graph</span>
                <span class="n">graph</span><span class="o">.</span><span class="n">remove_nodes_from</span><span class="p">(</span><span class="n">secondary_ops</span><span class="p">)</span>

        <span class="c1"># add layer to node updates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_updates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">)</span>

        <span class="c1"># parse edges</span>
        <span class="c1">#############</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">top_layer</span><span class="p">()</span>

        <span class="c1"># collect output variables</span>
        <span class="n">source_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">edge_indices</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="n">op_names</span><span class="p">,</span> <span class="n">var_names</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="n">svar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;source_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">svar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="n">op_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
            <span class="n">var_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
            <span class="n">source_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source_node</span><span class="p">)</span>
            <span class="n">target_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target_node</span><span class="p">)</span>
            <span class="n">edge_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge_idx</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">source_nodes</span><span class="p">,</span> <span class="n">target_nodes</span><span class="p">,</span> <span class="n">edge_indices</span><span class="p">):</span>

            <span class="c1"># extract edge information</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">)</span>
            <span class="n">sidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;source_idx&#39;</span><span class="p">)</span>
            <span class="n">tidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;target_idx&#39;</span><span class="p">)</span>
            <span class="n">svar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;source_var&#39;</span><span class="p">)</span>
            <span class="n">tvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">add_project</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">,</span> <span class="s1">&#39;add_project&#39;</span><span class="p">)</span>

            <span class="c1"># get original target variable</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">tvar</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">target_node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_old&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">tvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">target_node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

            <span class="c1"># define target index</span>
            <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tidx</span><span class="p">:</span>
                <span class="n">tidx_tmp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">tidx_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tidx_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">tidx_tmp</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">tidx</span> <span class="ow">and</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>

            <span class="c1"># create mapping equation and its arguments</span>
            <span class="n">d</span> <span class="o">=</span> <span class="s2">&quot;[target_idx]&quot;</span> <span class="k">if</span> <span class="n">tidx</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="s2">&quot;[source_idx]&quot;</span> <span class="k">if</span> <span class="n">sidx</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">assign</span> <span class="o">=</span> <span class="s1">&#39;+=&#39;</span> <span class="k">if</span> <span class="n">add_project</span> <span class="k">else</span> <span class="s1">&#39;=&#39;</span>
            <span class="n">eq</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;target_var</span><span class="si">{d}</span><span class="s2"> </span><span class="si">{assign}</span><span class="s2"> source_var</span><span class="si">{idx}</span><span class="s2"> * weight&quot;</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">svar</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">svar</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">svar</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span> <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">weight</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">tidx</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>
            <span class="k">if</span> <span class="n">sidx</span><span class="p">:</span>
                <span class="n">args</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="s1">&#39;int32&#39;</span><span class="p">,</span>
                                              <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sidx</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)}</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tvar</span>
            <span class="n">args</span><span class="p">[</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">svar</span>

            <span class="c1"># parse mapping</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">parse_equation_list</span><span class="p">([</span><span class="n">eq</span><span class="p">],</span> <span class="n">args</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                                       <span class="n">scope</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2">/</span><span class="si">{source_node}</span><span class="s2">/</span><span class="si">{target_node}</span><span class="s2">/</span><span class="si">{edge_idx}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># store information in network config</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source_node</span><span class="p">,</span> <span class="n">target_node</span><span class="p">,</span> <span class="n">edge_idx</span><span class="p">]</span>

            <span class="c1"># update edge attributes</span>
            <span class="n">edge</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">edge_updates</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">]</span> <span class="k">else</span> <span class="p">[]</span>

<div class="viewcode-block" id="ComputeGraph.run"><a class="viewcode-back" href="../../../pyrates.backend.html#pyrates.backend.computegraph.ComputeGraph.run">[docs]</a>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">simulation_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">sampling_step_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">out_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
            <span class="n">profile</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Simulate the backend behavior over time via a tensorflow session.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        simulation_time</span>
<span class="sd">            Simulation time in seconds.</span>
<span class="sd">        inputs</span>
<span class="sd">            Inputs for placeholder variables. Each key is a tuple that specifies a placeholder variable in the graph</span>
<span class="sd">            in the following format: (node_name, op_name, var_name). Each value is an array that defines the input for</span>
<span class="sd">            the placeholder variable over time (first dimension).</span>
<span class="sd">        outputs</span>
<span class="sd">            Output variables that will be returned. Each key is the desired name of an output variable and each value is</span>
<span class="sd">            a tuple that specifies a variable in the graph in the following format: (node_name, op_name, var_name).</span>
<span class="sd">        sampling_step_size</span>
<span class="sd">            Time in seconds between sampling points of the output variables.</span>
<span class="sd">        out_dir</span>
<span class="sd">            Directory in which to store outputs.</span>
<span class="sd">        verbose</span>
<span class="sd">            If true, status updates will be printed to the console.</span>
<span class="sd">        profile</span>
<span class="sd">            Can be used to extract information about graph execution time and memory load. Can be:</span>
<span class="sd">            - `t` for returning the total graph execution time.</span>
<span class="sd">            - `m` for returning the peak memory consumption during graph excecution.</span>
<span class="sd">            - `mt` or `tm` for both</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[DataFrame, Tuple[DataFrame, float, float]]</span>
<span class="sd">            First entry of the tuple contains the output variables in a pandas dataframe, the second contains the</span>
<span class="sd">            simulation time in seconds and the third the peak memory consumption. If profiling was not chosen during</span>
<span class="sd">            call of the function, only the dataframe will be returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>

        <span class="c1"># prepare simulation</span>
        <span class="c1">####################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preparing the simulation...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">remove_layer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">top_layer</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_run</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># basic simulation parameters initialization</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">simulation_time</span><span class="p">:</span>
            <span class="n">simulation_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">sim_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">simulation_time</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sampling_step_size</span><span class="p">:</span>
            <span class="n">sampling_step_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">sampling_steps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sampling_step_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span>

        <span class="c1"># add output variables to the backend</span>
        <span class="c1">#####################################</span>

        <span class="c1"># define output variables</span>
        <span class="n">output_col</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">output_cols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_keys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">outputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">val_split</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">val_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">val_split</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">val_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_var</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">var_name</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{key}</span><span class="s2">_col&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">var_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var_val</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">var_shape</span> <span class="ow">in</span> <span class="n">output_shapes</span><span class="p">:</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="n">output_shapes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">var_shape</span><span class="p">)</span>
                        <span class="n">output_cols</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_val</span><span class="p">)</span>
                        <span class="n">output_keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_key</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">output_cols</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">var_val</span><span class="p">])</span>
                        <span class="n">output_keys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">var_key</span><span class="p">])</span>
                        <span class="n">output_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_shape</span><span class="p">)</span>

                <span class="c1"># create counting index for collector variables</span>
                <span class="n">output_col</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_output_layer</span><span class="p">(</span><span class="n">outputs</span><span class="o">=</span><span class="n">output_cols</span><span class="p">,</span>
                                                                <span class="n">sampling_steps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">sim_steps</span><span class="o">/</span><span class="n">sampling_steps</span><span class="p">),</span>
                                                                <span class="n">out_shapes</span><span class="o">=</span><span class="n">output_shapes</span><span class="p">))</span>

        <span class="c1"># add input variables to the backend</span>
        <span class="c1">####################################</span>

        <span class="k">if</span> <span class="n">inputs</span><span class="p">:</span>

            <span class="n">inp_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

            <span class="c1"># linearize input dictionary</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="n">key_split</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="s1">&#39;_combined&#39;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]:</span>

                    <span class="c1"># fully vectorized case: add vectorized placeholder variable to input dictionary</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">],</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                    <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="s1">&#39;_all&#39;</span> <span class="ow">in</span> <span class="n">key_tmp</span> <span class="k">for</span> <span class="n">key_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>

                    <span class="c1"># node-vectorized case</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>

                        <span class="c1"># go through all nodes, extract the variable and add it to input dict</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                            <span class="n">i_new</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
                            <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i_new</span><span class="p">],</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                            <span class="n">i</span> <span class="o">+=</span> <span class="n">i_new</span>

                    <span class="k">elif</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                        <span class="c1"># add placeholder variable of node(s) to input dictionary</span>
                        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                        <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">node</span> <span class="ow">in</span> <span class="n">key_tmp</span> <span class="k">for</span> <span class="n">key_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()])</span> <span class="ow">or</span> \
                            <span class="nb">any</span><span class="p">([</span><span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">key_tmp</span> <span class="k">for</span> <span class="n">key_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>

                        <span class="n">node_tmp</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">node</span> <span class="k">else</span> <span class="n">node</span>

                        <span class="c1"># add vectorized placeholder variable of specified node type to input dictionary</span>
                        <span class="k">for</span> <span class="n">node_tmp2</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                            <span class="k">if</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="n">node_tmp2</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp2</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                        <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># non-vectorized case</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>

                        <span class="c1"># go through all nodes, extract the variable and add it to input dict</span>
                        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                            <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

                    <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">node</span> <span class="ow">in</span> <span class="n">key_tmp</span> <span class="k">for</span> <span class="n">key_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>

                        <span class="c1"># extract variables from nodes of specified type</span>
                        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                            <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_tmp</span><span class="p">:</span>
                                <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">attr</span><span class="p">)</span>
                                <span class="n">inp_dict</span><span class="p">[</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">val</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="p">(</span><span class="n">sim_steps</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add inputs to graph</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_layer</span><span class="p">(</span><span class="n">to_beginning</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># create counting index for input variables</span>
            <span class="n">in_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="s1">&#39;state_var&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;in_var_idx&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,),</span> <span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">scope</span><span class="o">=</span><span class="s2">&quot;network_inputs&quot;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inp_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{var.short_name}</span><span class="s2">_inp&quot;</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="s1">&#39;short_name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;var_inp&quot;</span>
                <span class="n">in_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_var</span><span class="p">(</span><span class="n">vtype</span><span class="o">=</span><span class="s1">&#39;state_var&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">var_name</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="s2">&quot;network_inputs&quot;</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
                <span class="n">in_var_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="n">in_var</span><span class="p">,</span> <span class="n">in_idx</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="s2">&quot;network_inputs&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">vars</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">in_var_idx</span><span class="p">,</span> <span class="n">scope</span><span class="o">=</span><span class="s2">&quot;network_inputs&quot;</span><span class="p">)</span>

            <span class="c1"># create increment operator for counting index</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="s1">&#39;+=&#39;</span><span class="p">,</span> <span class="n">in_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int32&#39;</span><span class="p">),</span> <span class="n">scope</span><span class="o">=</span><span class="s2">&quot;network_inputs&quot;</span><span class="p">)</span>

        <span class="c1"># run simulation</span>
        <span class="c1">################</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Running the simulation...&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">profile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">sim_steps</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_col</span><span class="p">,</span> <span class="n">sampling_steps</span><span class="o">=</span><span class="n">sampling_steps</span><span class="p">,</span>
                                          <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span> <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_col</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">memory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">steps</span><span class="o">=</span><span class="n">sim_steps</span><span class="p">,</span> <span class="n">outputs</span><span class="o">=</span><span class="n">output_col</span><span class="p">,</span> <span class="n">out_dir</span><span class="o">=</span><span class="n">out_dir</span><span class="p">,</span>
                                                        <span class="n">profile</span><span class="o">=</span><span class="n">profile</span><span class="p">,</span> <span class="n">sampling_steps</span><span class="o">=</span><span class="n">sampling_steps</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span> <span class="ow">and</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">simulation_time</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{simulation_time}</span><span class="s2">s of backend behavior were simulated in </span><span class="si">{time}</span><span class="s2"> s given a &quot;</span>
                      <span class="n">f</span><span class="s2">&quot;simulation resolution of </span><span class="si">{self.dt}</span><span class="s2"> s.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;ComputeGraph computations finished after </span><span class="si">{time}</span><span class="s2"> seconds.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;finished!&#39;</span><span class="p">)</span>

        <span class="c1"># store output variables in data frame</span>
        <span class="c1">######################################</span>

        <span class="c1"># ungroup grouped output variables</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">names</span><span class="p">,</span> <span class="n">group_key</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">output_keys</span><span class="p">,</span> <span class="n">output_col</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">out_group</span> <span class="o">=</span> <span class="n">output_col</span><span class="p">[</span><span class="n">group_key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
                <span class="n">outputs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_group</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>

        <span class="n">out_var_vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out_var_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">outputs</span><span class="p">):</span>

            <span class="n">var</span> <span class="o">=</span> <span class="n">outputs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">var_tmp</span> <span class="o">=</span> <span class="n">var</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">var_tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">var_tmp</span><span class="p">)</span>
                    <span class="n">out_var_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var_tmp</span><span class="p">)</span>
                    <span class="n">key_split</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                    <span class="n">var_name</span> <span class="o">=</span> <span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="p">[:</span><span class="n">var_name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_col&#39;</span><span class="p">)]</span>
                    <span class="n">node_name</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">out_var_names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var_name</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{node_name}</span><span class="s1">_</span><span class="si">{i}</span><span class="s1">&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="n">out_var_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
                <span class="n">key_split</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">key_split</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="n">var_name</span><span class="p">[:</span><span class="n">var_name</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;_col&#39;</span><span class="p">)]</span>
                <span class="n">node_name</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">key_split</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">out_var_names</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">var_name</span><span class="p">,</span> <span class="n">node_name</span><span class="p">))</span>

        <span class="c1"># create multi-index</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">out_var_names</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">])</span>

        <span class="c1"># create dataframe</span>
        <span class="k">if</span> <span class="n">out_var_vals</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">out_var_vals</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="n">simulation_time</span><span class="p">,</span> <span class="n">sampling_step_size</span><span class="p">)[</span><span class="o">-</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
            <span class="n">out_vars</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="p">:],</span>
                                 <span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">,</span>
                                 <span class="n">columns</span><span class="o">=</span><span class="n">index</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_vars</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># return results</span>
        <span class="c1">################</span>

        <span class="k">if</span> <span class="n">profile</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">out_vars</span><span class="p">,</span> <span class="n">time</span><span class="p">,</span> <span class="n">memory</span>
        <span class="k">return</span> <span class="n">out_vars</span></div>

<div class="viewcode-block" id="ComputeGraph.get_var"><a class="viewcode-back" href="../../../pyrates.backend.html#pyrates.backend.computegraph.ComputeGraph.get_var">[docs]</a>    <span class="k">def</span> <span class="nf">get_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extracts a variable from the graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node(s), the variable exists on. Can be &#39;all&#39; for all nodes, or a sub-string that defines a</span>
<span class="sd">            class of nodes or a specific node name.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the operator the variable belongs to.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the variable.</span>
<span class="sd">        var_name</span>
<span class="sd">            Name under which the variable should be returned</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments that may be used to pass arguments for the backend like name scopes.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Dictionary with all variables found in the network that match the provided signature.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">var_name</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="n">var</span>
        <span class="n">var_col</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>

            <span class="c1"># collect output variable from every node in backend</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">var_col</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{node}</span><span class="s1">/</span><span class="si">{op}</span><span class="s1">/</span><span class="si">{var_name}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="c1"># get output variable of specific backend node</span>
            <span class="n">var_col</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{node}</span><span class="s1">/</span><span class="si">{op}</span><span class="s1">/</span><span class="si">{var_name}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">any</span><span class="p">([</span><span class="n">node</span> <span class="ow">in</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()]):</span>

            <span class="c1"># get output variable from backend nodes of a certain type</span>
            <span class="k">for</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_tmp</span><span class="p">:</span>
                    <span class="n">var_col</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{node}</span><span class="s1">/</span><span class="si">{op}</span><span class="s1">/</span><span class="si">{var_name}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="c1"># get output variable of specific, vectorized backend node</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">node_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">node_tmp</span><span class="p">:</span>
                    <span class="n">var_col</span><span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{node}</span><span class="s1">/</span><span class="si">{op}</span><span class="s1">/</span><span class="si">{var_name}</span><span class="s1">_</span><span class="si">{i}</span><span class="s1">&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="o">=</span><span class="n">node_tmp</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="n">var</span><span class="p">,</span>
                                                                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">var_col</span></div>

<div class="viewcode-block" id="ComputeGraph.clear"><a class="viewcode-back" href="../../../pyrates.backend.html#pyrates.backend.computegraph.ComputeGraph.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears the backend graph from all operations and variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_add_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ops</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">node_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">primary_ops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a number of operations to the backend graph.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ops</span>
<span class="sd">            Names of the operators that should be parsed into the graph.</span>
<span class="sd">        node_name</span>
<span class="sd">            Name of the node that the operators belong to.</span>
<span class="sd">        updates</span>
<span class="sd">            Key-value pairs of operations already parsed into the backend graph.</span>
<span class="sd">        primary_ops</span>
<span class="sd">            Indicates, whether the operations are the first to be parsed into the graph or not.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set up update operation collector variable</span>
        <span class="n">updates</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># add operations of same hierarchical lvl to compute graph</span>
        <span class="c1">############################################################</span>

        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>

            <span class="n">updates</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># retrieve operator and operator args</span>
            <span class="n">op_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">)</span>
            <span class="n">op_args</span><span class="p">[</span><span class="s1">&#39;dt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dt</span>
            <span class="n">op_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;operator&#39;</span><span class="p">)</span>

            <span class="c1"># handle operator inputs</span>
            <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># go through inputs to variable</span>
                <span class="k">if</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]:</span>

                    <span class="n">in_ops_col</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">reduce_inputs</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bool</span> <span class="k">else</span> <span class="kc">False</span>

                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">in_op</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]):</span>

                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">in_op</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_op</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                            <span class="n">reduce_dim</span> <span class="o">=</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                            <span class="n">in_ops_tmp</span> <span class="o">=</span> <span class="p">[]</span>

                            <span class="c1"># collect multiple inputs to op</span>
                            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">in_op</span><span class="p">:</span>
                                <span class="n">in_ops_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_input</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">primary_ops</span><span class="p">))</span>

                            <span class="c1"># map those inputs correctly</span>
                            <span class="n">in_ops_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_map_multiple_inputs</span><span class="p">(</span><span class="n">in_ops_tmp</span><span class="p">,</span> <span class="n">reduce_dim</span><span class="p">,</span>
                                                                        <span class="n">scope</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2">/</span><span class="si">{node_name}</span><span class="s2">/</span><span class="si">{op_name}</span><span class="s2">&quot;</span><span class="p">)</span>
                                              <span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>

                            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">in_op</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_op</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">in_op</span> <span class="o">=</span> <span class="n">in_op</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                            <span class="c1"># collect single input to op</span>
                            <span class="n">in_ops_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_input</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">primary_ops</span><span class="p">))</span>

                    <span class="c1"># for multiple multiple input operations</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_ops_col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                        <span class="c1"># find shape of smallest input variable</span>
                        <span class="n">min_shape</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">in_ops_col</span><span class="p">])</span>

                        <span class="c1"># append input variables to list and reshape them if necessary</span>
                        <span class="n">in_ops</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">in_ops_col</span><span class="p">:</span>
                            <span class="n">shape</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                            <span class="k">if</span> <span class="n">shape</span> <span class="o">&gt;</span> <span class="n">min_shape</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">shape</span> <span class="o">%</span> <span class="n">min_shape</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Shapes of inputs do not match: &quot;</span>
                                                     <span class="n">f</span><span class="s2">&quot;</span><span class="si">{inp[&#39;sources&#39;]}</span><span class="s2"> cannot be stacked.&quot;</span><span class="p">)</span>
                                <span class="n">multiplier</span> <span class="o">=</span> <span class="n">shape</span> <span class="o">//</span> <span class="n">min_shape</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">multiplier</span><span class="p">):</span>
                                    <span class="n">in_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="n">min_shape</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">min_shape</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">in_ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

                        <span class="c1"># map inputs to target</span>
                        <span class="n">in_ops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_map_multiple_inputs</span><span class="p">(</span><span class="n">in_ops</span><span class="p">,</span> <span class="n">reduce_inputs</span><span class="p">,</span>
                                                           <span class="n">scope</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2">/</span><span class="si">{node_name}</span><span class="s2">/</span><span class="si">{op_name}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="c1"># for a single input variable</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">in_ops</span> <span class="o">=</span> <span class="n">in_ops_col</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="c1"># add input variable to dictionary</span>
                    <span class="n">op_args</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">in_ops</span>

            <span class="c1"># parse equations into tensorflow</span>
            <span class="n">op_args</span> <span class="o">=</span> <span class="n">parse_equation_list</span><span class="p">(</span><span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">],</span> <span class="n">op_args</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">,</span>
                                          <span class="n">scope</span><span class="o">=</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{self.name}</span><span class="s2">/</span><span class="si">{node_name}</span><span class="s2">/</span><span class="si">{op_name}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># store variables updates</span>
            <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_val</span> <span class="ow">in</span> <span class="n">op_args</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">updates</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">var_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_val</span>

        <span class="c1"># store variables updates in net_config</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="n">updates</span><span class="p">:</span>
            <span class="n">op_vars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">var_key</span><span class="p">,</span> <span class="n">var_val</span> <span class="ow">in</span> <span class="n">updates</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">op_vars</span><span class="p">[</span><span class="n">var_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_val</span>

        <span class="c1"># advance in backend layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">next_layer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_op_input</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">in_op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">primary_ops</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extracts inputs of operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node the operators belong to.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target node.</span>
<span class="sd">        in_op</span>
<span class="sd">            Name of the source node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Backend variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">primary_ops</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Input found in primary operator </span><span class="si">{op}</span><span class="s1"> on node </span><span class="si">{node}</span><span class="s1">. &#39;</span>
                             <span class="n">f</span><span class="s1">&#39;This operator should have no node-internal inputs. &#39;</span>
                             <span class="n">f</span><span class="s1">&#39;Please move the operator inputs to the node level or change the &#39;</span>
                             <span class="n">f</span><span class="s1">&#39;input-output relationships between the node operators.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">var_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">,</span> <span class="n">retrieve</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">in_op</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">var</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Wrong operator order on node </span><span class="si">{node}</span><span class="s1">. Operator </span><span class="si">{op}</span><span class="s1"> &#39;</span>
                                 <span class="n">f</span><span class="s1">&#39;needs input from operator </span><span class="si">{in_op}</span><span class="s1"> which has not been &#39;</span>
                                 <span class="n">f</span><span class="s1">&#39;processed yet. Please consider changing the operator order &#39;</span>
                                 <span class="n">f</span><span class="s1">&#39;or dependencies.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="k">def</span> <span class="nf">_map_multiple_inputs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">reduce_dim</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Creates mapping between multiple input variables and a single output variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        inputs</span>
<span class="sd">            Input variables.</span>
<span class="sd">        reduce_dim</span>
<span class="sd">            If true, input variables will be summed up, if false, they will be concatenated.</span>
<span class="sd">        kwargs</span>
<span class="sd">            Additional keyword arguments for the backend.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Summed up or concatenated input variables.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">inp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">stack_vars</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">next_layer</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">reduce_dim</span><span class="p">:</span>
            <span class="n">inp_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inp_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">add_op</span><span class="p">(</span><span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> \
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">inp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">node_updates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">layer</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">inp_transform</span>

    <span class="k">def</span> <span class="nf">_get_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extract attribute from node of the network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the attribute on the node.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the operator. Only needs to be provided for operator variables.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Node attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">op</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">vals</span>

    <span class="k">def</span> <span class="nf">_set_node_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets attribute on a node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the attribute.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the operator, the attribute belongs to. Does not need to be provided for attributes that do not</span>
<span class="sd">            belong to an operator.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            New node attribute value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">op</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">vals_updated</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;node&#39;</span><span class="p">][</span><span class="s1">&#39;op_graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">vals_updated</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">vals_updated</span>

    <span class="k">def</span> <span class="nf">_get_edge_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">retrieve_from_node</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extracts attribute from edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node.</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node.</span>
<span class="sd">        edge</span>
<span class="sd">            Index or name of the edge.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the attribute</span>
<span class="sd">        retrieve_from_node</span>
<span class="sd">            If true, the attribute will be retrieved from the source or target node. Only relevant if the attribute is</span>
<span class="sd">            &#39;source_var&#39; or &#39;target_var&#39;. Else, the value of the attribute on the edge will be returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Edge attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">if</span> <span class="s1">&#39;var&#39;</span> <span class="ow">in</span> <span class="n">attr</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr_val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span> <span class="ow">and</span> <span class="n">retrieve_from_node</span><span class="p">:</span>
                <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">attr_val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;source&#39;</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">:</span>
                    <span class="n">attr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attr_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">attr_val</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">attr_val</span>

    <span class="k">def</span> <span class="nf">_set_edge_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets value of an edge attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node.</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node.</span>
<span class="sd">        edge</span>
<span class="sd">            Name or index of the edge.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the attribute.</span>
<span class="sd">        val</span>
<span class="sd">            New value of the attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Value of the updated edge attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_op_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">retrieve</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extracts attribute of an operator.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the operator on the node.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the attribute of the operator on the node.</span>
<span class="sd">        retrieve</span>
<span class="sd">            If attribute is output, this can be set to True to receive the handle to the output variable, or to false</span>
<span class="sd">            to receive the name of the output variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Operator attribute.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span> <span class="ow">and</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">op</span><span class="p">]:</span>
            <span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">attr_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">op</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;{list(attr_idx)}&quot;</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">attr_idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span> <span class="k">else</span> <span class="n">attr_idx</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backend</span><span class="o">.</span><span class="n">apply_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">retrieve</span> <span class="k">else</span> <span class="n">attr_idx</span>
        <span class="k">elif</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="p">:</span>
            <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;op_graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Node with name </span><span class="si">{node}</span><span class="s1"> is not part of this network.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span> <span class="ow">and</span> <span class="n">retrieve</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="s1">&#39;output&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr_val</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="s1">&#39;keys&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">attr_val</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="n">attr</span><span class="p">):</span>
            <span class="n">attr_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">attr_val</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">attr_val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">e</span>

        <span class="k">return</span> <span class="n">attr_val</span>

    <span class="k">def</span> <span class="nf">_set_op_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sets value of an operator attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the node.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the operator on the node.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the operator attribute on the node.</span>
<span class="sd">        val</span>
<span class="sd">            New value of the operator attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Updated attribute value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;op_graph&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">op</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;output&#39;</span><span class="p">:</span>
            <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">][</span><span class="n">op</span><span class="p">[</span><span class="n">attr</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">][</span><span class="n">op</span><span class="p">[</span><span class="n">attr</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="n">attr</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="n">attr</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">],</span> <span class="n">attr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">op</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">return</span> <span class="n">op</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_apply_idx</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Applies index to graph variable. Only used for observing graph variables,</span>
<span class="sd">        not for graph internal computations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        var</span>
<span class="sd">            Graph variable.</span>
<span class="sd">        idx</span>
<span class="sd">            Index to the variable dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Any</span>
<span class="sd">            Indexed variable.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">var</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_nodes_with_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Extracts nodes from graph for which a certain attribute takes on a certain value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attr</span>
<span class="sd">            Attribute of interest on the nodes.</span>
<span class="sd">        val</span>
<span class="sd">            Attribute value that selected nodes should have.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list</span>
<span class="sd">            Nodes for which the attribute takes on the indicated value.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
            <span class="n">test_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">val</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">==</span> <span class="n">test_val</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">val</span> <span class="o">==</span> <span class="n">test_val</span><span class="p">:</span>
                <span class="n">nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nodes</span>

    <span class="k">def</span> <span class="nf">_contains_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_node</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checks whether a vectorized graph node contains an original, non-vectorized target node or not.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Vectorized graph node.</span>
<span class="sd">        target_node</span>
<span class="sd">            Less vectorized node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            Indicates whether target node is contained in the vectorized node or not.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">node_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">target_node</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">node_map</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Could not identify target node </span><span class="si">{target_node}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_edges_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Extract all edges between a source and a target node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node.</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        List[tuple]</span>
<span class="sd">            Collection of all edges between source and target.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;_all&#39;</span> <span class="ow">in</span> <span class="n">source</span> <span class="ow">and</span> <span class="s1">&#39;_all&#39;</span> <span class="ow">in</span> <span class="n">target</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="s1">&#39;_combined&#39;</span> <span class="ow">in</span> <span class="n">source</span> <span class="ow">and</span> <span class="s1">&#39;_combined&#39;</span> <span class="ow">in</span> <span class="n">target</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">source_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">target_tmp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_node</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">source_tmp</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_node</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">):</span>
                        <span class="n">edges</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span>
                                  <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">))]</span>
            <span class="k">return</span> <span class="n">edges</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">number_of_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">_get_edge_conn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Extracts weight and delay vectors of an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node.</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node.</span>
<span class="sd">        edge</span>
<span class="sd">            Name of index of the edge.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Tuple[np.ndarray, np.ndarray]</span>
<span class="sd">            Weight and delay of the edge (both are arrays).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check delay of edge</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">delay</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Automatic optimization of the graph (i.e. method `vectorize`&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; cannot be applied to networks with variables of 2 or more&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; dimensions. Delay of edge </span><span class="si">{edge}</span><span class="s2"> between </span><span class="si">{source}</span><span class="s2"> and </span><span class="si">{target}</span><span class="s2"> has shape&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; </span><span class="si">{delay.shape}</span><span class="s2">. Please turn of the `vectorize` option or change&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; the edges&#39; dimensionality.&quot;</span><span class="p">)</span>

        <span class="c1"># check weight of edge</span>
        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="s1">&#39;weight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">weight</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Automatic optimization of the graph (i.e. method `vectorize`&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; cannot be applied to networks with variables of 2 or more&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; dimensions. Weight of edge </span><span class="si">{edge}</span><span class="s2"> between </span><span class="si">{source}</span><span class="s2"> and </span><span class="si">{target}</span><span class="s2"> has shape&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; </span><span class="si">{weight.shape}</span><span class="s2">. Please turn of the `vectorize` option or&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; change the edges&#39; dimensionality.&quot;</span><span class="p">)</span>

        <span class="c1"># match dimensionality of delay and weight</span>
        <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">delay</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="p">(</span><span class="n">delay</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">delay</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">delay</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Dimensionality of weights and delays of edge between </span><span class="si">{source}</span><span class="s2"> and </span><span class="si">{target}</span><span class="s2">&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; do not match. They are of shape </span><span class="si">{weight.shape}</span><span class="s2"> and </span><span class="si">{delay.shape}</span><span class="s2">.&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; Please turn of the `vectorize` option or change the dimensionality of the&quot;</span>
                             <span class="n">f</span><span class="s2">&quot; edge&#39;s attributes.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">weight</span><span class="p">,</span> <span class="n">delay</span>

    <span class="k">def</span> <span class="nf">_get_edge_var_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">idx_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Extracts indices of an edge that map vectorized weights and delays to the original edges.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source</span>
<span class="sd">            Name of the source node.</span>
<span class="sd">        target</span>
<span class="sd">            Name of the target node.</span>
<span class="sd">        edge</span>
<span class="sd">            Index or name of the edge.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Union[list, None]</span>
<span class="sd">            List of indices.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">idx_type</span> <span class="o">==</span> <span class="s1">&#39;source&#39;</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="s1">&#39;source_idx&#39;</span>
            <span class="n">node_var</span> <span class="o">=</span> <span class="s1">&#39;source_var&#39;</span>
            <span class="n">node_to_idx</span> <span class="o">=</span> <span class="n">source</span>
        <span class="k">elif</span> <span class="n">idx_type</span> <span class="o">==</span> <span class="s1">&#39;target&#39;</span><span class="p">:</span>
            <span class="n">var</span> <span class="o">=</span> <span class="s1">&#39;target_idx&#39;</span>
            <span class="n">node_var</span> <span class="o">=</span> <span class="s1">&#39;target_var&#39;</span>
            <span class="n">node_to_idx</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Wrong `idx_type`. Please, choose either `source` or `target`.&#39;</span><span class="p">)</span>

        <span class="n">var_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var_idx</span><span class="p">:</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">node_var</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_to_idx</span><span class="p">][</span><span class="n">op</span><span class="p">][</span><span class="n">var</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">idx_new</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">var_idx</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                        <span class="n">idx_new</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span>
                    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="n">idx_new</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx_new</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx_new</span> <span class="o">=</span> <span class="p">[[</span><span class="n">idx</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">op</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">][</span><span class="n">node_var</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">idx_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_to_idx</span><span class="p">][</span><span class="n">op</span><span class="p">][</span><span class="n">var</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">idx_new</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
                    <span class="n">idx_new</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_new</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx_new</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">idx_new</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">idx_new</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">idx_new</span>

    <span class="k">def</span> <span class="nf">_sort_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edges</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">tuple</span><span class="p">],</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Sorts edges according to the given edge attribute.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        edges</span>
<span class="sd">            Collection of edges of interest.</span>
<span class="sd">        attr</span>
<span class="sd">            Name of the edge attribute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict</span>
<span class="sd">            Key-value pairs of the different values the attribute can take on (keys) and the list of edges for which</span>
<span class="sd">            the attribute takes on that value (value).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">edge_idx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">source</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">edge</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_idx</span><span class="p">:</span>
                    <span class="n">edge_idx</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="n">edge_idx</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)]</span>
                <span class="n">edge_idx</span><span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">edge_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">edge_info</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges_new</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">edge_info</span><span class="p">[</span><span class="n">attr</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edges_new</span><span class="p">[</span><span class="n">edge_info</span><span class="p">[</span><span class="n">attr</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">edge</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">edges_new</span>

    <span class="k">def</span> <span class="nf">_add_edge_buffer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">buffer_length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds a buffer variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        idx</span>
<span class="sd">            Index of the buffer variable for that specific edge.</span>
<span class="sd">        buffer_length</span>
<span class="sd">            Length of the time-buffer that should be added to realize edge delays.</span>
<span class="sd">        edge</span>
<span class="sd">            Edge identifier (source_name, target_name, edge_idx).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">op_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span>

        <span class="c1"># create buffer variable definitions</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">buffer_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,)</span>
            <span class="n">buffer_shape_reset</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">buffer_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">buffer_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">buffer_shape_reset</span> <span class="o">=</span> <span class="p">(</span><span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span>
                                            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape</span><span class="p">,</span>
                                            <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                            <span class="p">},</span>
                    <span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">_reset&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;constant&#39;</span><span class="p">,</span>
                                                  <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span>
                                                  <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">buffer_shape_reset</span><span class="p">,</span>
                                                  <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                                  <span class="p">}</span>
                    <span class="p">}</span>

        <span class="c1"># create buffer equations</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">target_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">eqs_op_read</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[0]&quot;</span><span class="p">]</span>
            <span class="n">eqs_op_rotate</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2"> = concat((</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[1:], </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">_reset), 0)&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eqs_op_read</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[:, 0]&quot;</span><span class="p">]</span>
            <span class="n">eqs_op_rotate</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2"> = concat((</span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">[:, 1:], </span><span class="si">{var}</span><span class="s2">_buffer_</span><span class="si">{idx}</span><span class="s2">_reset), 1)&quot;</span><span class="p">]</span>

        <span class="c1"># add buffer operators to operator graph</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                          <span class="n">operator</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="p">{},</span>
                                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                                    <span class="s1">&#39;equations&#39;</span><span class="p">:</span> <span class="n">eqs_op_rotate</span><span class="p">},</span>
                          <span class="n">variables</span><span class="o">=</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                          <span class="n">operator</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">],</span>
                                                                       <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}},</span>
                                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span>
                                    <span class="s1">&#39;equations&#39;</span><span class="p">:</span> <span class="n">eqs_op_read</span><span class="p">},</span>
                          <span class="n">variables</span><span class="o">=</span><span class="p">{})</span>

        <span class="c1"># connect operators to rest of the graph</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># add input information to target operator</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_read_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">],</span>
                           <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge information</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_attr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_buffer_rotate_</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{var}</span><span class="s1">_buffer_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_attr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;add_project&#39;</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_edge_input_collector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">edge</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Adds an input collector variable to an edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        node</span>
<span class="sd">            Name of the target node of the edge.</span>
<span class="sd">        op</span>
<span class="sd">            Name of the target operator of the edge.</span>
<span class="sd">        var</span>
<span class="sd">            Name of the target variable of the edge.</span>
<span class="sd">        idx</span>
<span class="sd">            Index of the input collector variable on that edge.</span>
<span class="sd">        edge</span>
<span class="sd">            Edge identifier (source_name, target_name, edge_idx).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">target_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">var</span><span class="p">)[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
        <span class="n">op_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span>

        <span class="c1"># create collector equation</span>
        <span class="n">eqs</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s2">&quot;</span><span class="si">{var}</span><span class="s2"> = </span><span class="si">{var}</span><span class="s2">_col_</span><span class="si">{idx}</span><span class="s2">&quot;</span><span class="p">]</span>

        <span class="c1"># create collector variable definition</span>
        <span class="n">var_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;vtype&#39;</span><span class="p">:</span> <span class="s1">&#39;state_var&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span>
                                         <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="n">target_shape</span><span class="p">,</span>
                                         <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="mf">0.</span>
                                         <span class="p">}}</span>

        <span class="c1"># add collector operator to operator graph</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span>
                          <span class="n">operator</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;inputs&#39;</span><span class="p">:</span> <span class="p">{},</span>
                                    <span class="s1">&#39;output&#39;</span><span class="p">:</span> <span class="n">var</span><span class="p">,</span>
                                    <span class="s1">&#39;equations&#39;</span><span class="p">:</span> <span class="n">eqs</span><span class="p">},</span>
                          <span class="n">variables</span><span class="o">=</span><span class="n">var_dict</span><span class="p">)</span>
        <span class="n">op_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">op</span><span class="p">)</span>

        <span class="c1"># add input information to target operator</span>
        <span class="n">op_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">op_inputs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">op_inputs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;sources&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">],</span>
                              <span class="s1">&#39;reduce_dim&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># update edge target information</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">edge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_edge_attr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{op}</span><span class="s1">_</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">/</span><span class="si">{var}</span><span class="s1">_col_</span><span class="si">{idx}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_net_config_consistency_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">net_config</span><span class="p">:</span> <span class="n">CircuitIR</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CircuitIR</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Checks whether the passed network configuration follows the expected intermediate representation structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        net_config</span>
<span class="sd">            Intermediate representation of the network configuration that should be translated into the backend.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CircuitIR</span>
<span class="sd">            The checked (and maybe slightly altered) network configuration.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check node attributes</span>
        <span class="c1">#######################</span>

        <span class="c1"># go through each node in the network  config</span>
        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="c1"># check whether an operation graph exists</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">op_graph</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="s1">&#39;node&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">op_graph</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Key `node` not found on node </span><span class="si">{node_name}</span><span class="s1">. Every node in the network configuration &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;needs a field with the key `node` under which &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;its operation graph and its template is stored.&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Attribute `op_graph` not found on node </span><span class="si">{node_name}</span><span class="s1">. Every node in the network &#39;</span>
                                     <span class="n">f</span><span class="s1">&#39;configuration needs a graph object stored under its `node` key, which contains &#39;</span>
                                     <span class="n">f</span><span class="s1">&#39;all information regarding its operators, variables,&#39;</span>
                                     <span class="n">f</span><span class="s1">&#39;and input-output relationships.&#39;</span><span class="p">)</span>

            <span class="c1"># go through the operations on the node</span>
            <span class="k">for</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># check whether the variable field exists on the operator</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">variables</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Key `variables` not found in operator </span><span class="si">{op_name}</span><span class="s1"> of node </span><span class="si">{node_name}</span><span class="s1">. Every &#39;</span>
                                   <span class="n">f</span><span class="s1">&#39;operator on a node needs a field `variables` under which all necessary &#39;</span>
                                   <span class="s1">&#39;variables are defined via key-value pairs.&#39;</span><span class="p">)</span>

                <span class="c1"># check whether the operator field exists on the operator</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">op_info</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;operator&#39;</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Key `operator` not found in operator </span><span class="si">{op_name}</span><span class="s1"> of node </span><span class="si">{node_name}</span><span class="s1">. Every &#39;</span>
                                   <span class="n">f</span><span class="s1">&#39;operator on a node needs a field `operator` under which all the equations, &#39;</span>
                                   <span class="s1">&#39;inputs and output are defined.&#39;</span><span class="p">)</span>

                <span class="c1"># go through the variables</span>
                <span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variables</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                    <span class="c1"># check definition of each variable</span>
                    <span class="n">var_def</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;state_var&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">),</span>
                                             <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span>
                                             <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                             <span class="p">},</span>
                               <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">,</span>
                                            <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                            <span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">},</span>
                               <span class="s1">&#39;placeholder&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">,</span>
                                               <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                               <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">},</span>
                               <span class="s1">&#39;raw&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;dtype&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                                       <span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="ne">KeyError</span><span class="p">}</span>
                               <span class="p">}</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">vtype</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;vtype&#39;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field `vtype` not found in variable definition of variable </span><span class="si">{var_name}</span><span class="s1"> of &#39;</span>
                                       <span class="n">f</span><span class="s1">&#39;operator </span><span class="si">{op_name}</span><span class="s1"> on node </span><span class="si">{node_name}</span><span class="s1">. Each variable needs a field `vtype`&#39;</span>
                                       <span class="n">f</span><span class="s1">&#39;that indicates whether the variable is a `state_var`, `constant` or &#39;</span>
                                       <span class="n">f</span><span class="s1">&#39;`placeholder`.&#39;</span><span class="p">)</span>
                    <span class="n">var_defs</span> <span class="o">=</span> <span class="n">var_def</span><span class="p">[</span><span class="n">vtype</span><span class="p">]</span>

                    <span class="c1"># check the value of the variable</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">var_defs</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ne">KeyError</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field `value` not found in variable definition of variable </span><span class="si">{var_name}</span><span class="s1"> of &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;operator </span><span class="si">{op_name}</span><span class="s1"> on node </span><span class="si">{node_name}</span><span class="s1">, but it is needed for variables of &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;type </span><span class="si">{vtype}</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">var_defs</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">var</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_defs</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

                    <span class="c1"># check the shape of the variable</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">shape</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_defs</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span>

                    <span class="c1"># check the data type of the variable</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_</span> <span class="o">=</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">var</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">var_defs</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="s1">&#39;value&#39;</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                        <span class="n">var</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">var</span><span class="p">[</span><span class="s1">&#39;dtype&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">var</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

                <span class="c1"># check whether the equations, inputs and output fields exist on the operator field</span>
                <span class="n">op_fields</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;equations&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;output&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">op_fields</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">_</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">op_info</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;equations&#39;</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field </span><span class="si">{field}</span><span class="s1"> not found in `operators` field of operator </span><span class="si">{op_name}</span><span class="s1"> on &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;node </span><span class="si">{node_name}</span><span class="s1">. Each operator should follow a list of equations that &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;needs to be provided at this position.&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;inputs&#39;</span><span class="p">:</span>
                            <span class="n">op_info</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field </span><span class="si">{field}</span><span class="s1"> not found in `operators` field of operator </span><span class="si">{op_name}</span><span class="s1"> on &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;node </span><span class="si">{node_name}</span><span class="s1">. Each operator should have an output, the name of which &#39;</span>
                                           <span class="n">f</span><span class="s1">&#39;needs to be provided at this position.&#39;</span><span class="p">)</span>

        <span class="c1"># check edge attributes</span>
        <span class="c1">#######################</span>

        <span class="c1"># go through edges</span>
        <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>

            <span class="n">edge</span> <span class="o">=</span> <span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

            <span class="c1"># check whether source and target variable information were provided</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;source_var&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field `source_var` not found on edge </span><span class="si">{idx}</span><span class="s1"> between </span><span class="si">{source}</span><span class="s1"> and </span><span class="si">{target}</span><span class="s1">. Every edge &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;needs information about the variable on the source node it should access that needs &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;to be provided at this position.&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">_</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;target_var&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Field `target_var` not found on edge </span><span class="si">{idx}</span><span class="s1"> between </span><span class="si">{source}</span><span class="s1"> and </span><span class="si">{target}</span><span class="s1">. Every edge &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;needs information about the variable on the target node it should access that needs &#39;</span>
                               <span class="n">f</span><span class="s1">&#39;to be provided at this position.&#39;</span><span class="p">)</span>

            <span class="c1"># check weight of edge</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">weight</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">)</span> <span class="o">*</span> <span class="n">weight</span>
                <span class="k">elif</span> <span class="s1">&#39;float&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">weight</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">)</span>
                <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">)</span>

            <span class="c1"># check delay of edge</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">delay</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">delay</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                        <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,))</span> <span class="o">+</span> <span class="n">delay</span>
                    <span class="k">if</span> <span class="s1">&#39;float&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">delay</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
                        <span class="n">delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">delay</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                    <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delay</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">net_config</span>

    <span class="k">def</span> <span class="nf">_vectorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vectorization_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;nodes&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Method that goes through the nodes and edges dicts and vectorizes those that are governed by the same</span>
<span class="sd">        operators/equations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vectorization_mode</span>
<span class="sd">            Can be &#39;none&#39; for no vectorization, &#39;nodes&#39; for vectorization over nodes and &#39;ops&#39; for vectorization over</span>
<span class="sd">            nodes and operations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;vectorizing the graph nodes...&#39;</span><span class="p">)</span>

        <span class="c1"># First stage: Vectorize over nodes</span>
        <span class="c1">###################################</span>

        <span class="k">if</span> <span class="n">vectorization_mode</span> <span class="ow">in</span> <span class="s1">&#39;nodesfull&#39;</span><span class="p">:</span>

            <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

            <span class="c1"># go through each node in net config and vectorize it with nodes that have the same operator structure</span>
            <span class="c1">######################################################################################################</span>

            <span class="k">while</span> <span class="n">nodes</span><span class="p">:</span>

                <span class="c1"># get nodes with same operators</span>
                <span class="n">op_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span>
                <span class="n">nodes_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_nodes_with_attr</span><span class="p">(</span><span class="s1">&#39;op_graph&#39;</span><span class="p">,</span> <span class="n">op_graph</span><span class="p">)</span>

                <span class="c1"># vectorize those nodes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_nodes</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes_tmp</span><span class="p">))</span>

                <span class="c1"># delete vectorized nodes from list</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes_tmp</span><span class="p">:</span>
                    <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

            <span class="c1"># adjust edges accordingly</span>
            <span class="c1">##########################</span>

            <span class="c1"># go through new nodes</span>
            <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="k">if</span> <span class="s1">&#39;_all&#39;</span> <span class="ow">in</span> <span class="n">source</span> <span class="ow">and</span> <span class="s1">&#39;_all&#39;</span> <span class="ow">in</span> <span class="n">target</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

            <span class="c1"># save changes to net config</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;_all&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># Second stage: Vectorize over operators</span>
        <span class="c1">########################################</span>

        <span class="k">if</span> <span class="n">vectorization_mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>

            <span class="c1"># create dictionary of operators of each node that will be used to check whether they have been vectorized</span>
            <span class="n">vec_info</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                <span class="n">vec_info</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                    <span class="n">vec_info</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">op</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># add new node to net config</span>
            <span class="n">new_node</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
            <span class="n">new_node_name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{self.name}</span><span class="s1">_combined&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">node</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;op_graph&#39;</span><span class="p">:</span> <span class="n">new_node</span><span class="p">})</span>
            <span class="n">new_node_name</span> <span class="o">+=</span> <span class="s1">&#39;.0&#39;</span>

            <span class="c1"># go through nodes and vectorize over their operators</span>
            <span class="n">node_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vec_info</span><span class="p">)</span>
            <span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">node_key</span> <span class="o">=</span> <span class="n">node_keys</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">([</span><span class="nb">all</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">vec_info</span><span class="o">.</span><span class="n">values</span><span class="p">()]):</span>

                <span class="n">changed_node</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">op_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_key</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># vectorize nodes on the operator in their hierarchical order</span>
                <span class="k">while</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>

                    <span class="c1"># get all operators that have no dependencies on other operators on node</span>
                    <span class="c1"># noinspection PyTypeChecker</span>
                    <span class="n">primary_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">op</span> <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">in_degree</span> <span class="ow">in</span> <span class="n">op_graph</span><span class="o">.</span><span class="n">in_degree</span> <span class="k">if</span> <span class="n">in_degree</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

                    <span class="k">for</span> <span class="n">op_key</span> <span class="ow">in</span> <span class="n">primary_ops</span><span class="p">:</span>

                        <span class="k">if</span> <span class="ow">not</span> <span class="n">vec_info</span><span class="p">[</span><span class="n">node_key</span><span class="p">][</span><span class="n">op_key</span><span class="p">]:</span>

                            <span class="c1"># check whether operator exists at other nodes</span>
                            <span class="n">nodes_to_vec</span> <span class="o">=</span> <span class="p">[]</span>

                            <span class="k">for</span> <span class="n">node_key_tmp</span> <span class="ow">in</span> <span class="n">vec_info</span><span class="p">:</span>

                                <span class="k">if</span> <span class="n">node_key_tmp</span> <span class="o">!=</span> <span class="n">node_key</span> <span class="ow">and</span> <span class="n">op_key</span> <span class="ow">in</span> <span class="n">vec_info</span><span class="p">[</span><span class="n">node_key_tmp</span><span class="p">]:</span>

                                    <span class="c1"># check if operator dependencies are vectorized already</span>
                                    <span class="n">deps_vectorized</span> <span class="o">=</span> <span class="kc">True</span>
                                    <span class="n">op_graph_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_key_tmp</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span>
                                    <span class="k">for</span> <span class="n">op_key_tmp</span> <span class="ow">in</span> <span class="n">op_graph_tmp</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
                                        <span class="k">if</span> <span class="n">op_key_tmp</span> <span class="o">==</span> <span class="n">op_key</span><span class="p">:</span>
                                            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">op_graph_tmp</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">op_key_tmp</span><span class="p">):</span>
                                                <span class="k">if</span> <span class="ow">not</span> <span class="n">vec_info</span><span class="p">[</span><span class="n">node_key_tmp</span><span class="p">][</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
                                                    <span class="n">node_key</span> <span class="o">=</span> <span class="n">node_key_tmp</span>
                                                    <span class="n">deps_vectorized</span> <span class="o">=</span> <span class="kc">False</span>

                                    <span class="k">if</span> <span class="n">deps_vectorized</span><span class="p">:</span>
                                        <span class="n">nodes_to_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_key_tmp</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">changed_node</span> <span class="o">=</span> <span class="kc">True</span>
                                        <span class="k">break</span>

                            <span class="k">if</span> <span class="n">nodes_to_vec</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">changed_node</span><span class="p">:</span>

                                <span class="c1"># vectorize op</span>
                                <span class="n">nodes_to_vec</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_key</span><span class="p">)</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_ops</span><span class="p">(</span><span class="n">op_key</span><span class="o">=</span><span class="n">op_key</span><span class="p">,</span>
                                                    <span class="n">nodes</span><span class="o">=</span><span class="n">nodes_to_vec</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                                                    <span class="n">new_node</span><span class="o">=</span><span class="n">new_node</span><span class="p">,</span>
                                                    <span class="n">new_node_name</span><span class="o">=</span><span class="n">new_node_name</span><span class="p">)</span>

                                <span class="c1"># indicate where vectorization was performed</span>
                                <span class="k">for</span> <span class="n">node_key_tmp</span> <span class="ow">in</span> <span class="n">nodes_to_vec</span><span class="p">:</span>
                                    <span class="n">vec_info</span><span class="p">[</span><span class="n">node_key_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                                <span class="c1"># remove vectorized operation from graph</span>
                                <span class="n">op_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">op_key</span><span class="p">)</span>

                            <span class="k">elif</span> <span class="n">changed_node</span><span class="p">:</span>
                                <span class="k">break</span>
                            <span class="k">else</span><span class="p">:</span>

                                <span class="c1"># add operation to new net configuration</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_ops</span><span class="p">(</span><span class="n">op_key</span><span class="o">=</span><span class="n">op_key</span><span class="p">,</span>
                                                    <span class="n">nodes</span><span class="o">=</span><span class="p">[</span><span class="n">node_key</span><span class="p">],</span>
                                                    <span class="n">new_node</span><span class="o">=</span><span class="n">new_node</span><span class="p">,</span>
                                                    <span class="n">new_node_name</span><span class="o">=</span><span class="n">new_node_name</span><span class="p">)</span>

                                <span class="c1"># mark operation on node as checked</span>
                                <span class="n">vec_info</span><span class="p">[</span><span class="n">node_key</span><span class="p">][</span><span class="n">op_key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

                                <span class="c1"># remove vectorized operation from graph</span>
                                <span class="n">op_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">op_key</span><span class="p">)</span>

                        <span class="k">else</span><span class="p">:</span>

                            <span class="c1"># remove operation from graph</span>
                            <span class="n">op_graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">op_key</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">changed_node</span><span class="p">:</span>
                        <span class="k">break</span>

                <span class="c1"># increment node</span>
                <span class="n">node_idx</span> <span class="o">=</span> <span class="n">node_idx</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">node_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">vec_info</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">node_key</span> <span class="o">=</span> <span class="n">node_keys</span><span class="p">[</span><span class="n">node_idx</span><span class="p">]</span>

            <span class="c1"># add dependencies between operators</span>
            <span class="k">for</span> <span class="n">target_op</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">new_node_name</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">):</span>
                <span class="n">op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">new_node_name</span><span class="p">,</span> <span class="s1">&#39;operator&#39;</span><span class="p">,</span> <span class="n">target_op</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">op</span><span class="p">[</span><span class="s1">&#39;inputs&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">source_op</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">source_op</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">sop</span> <span class="ow">in</span> <span class="n">source_op</span><span class="p">:</span>
                                <span class="n">new_node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">sop</span><span class="p">,</span> <span class="n">target_op</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_node</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source_op</span><span class="p">,</span> <span class="n">target_op</span><span class="p">)</span>

            <span class="c1"># adjust edges accordingly</span>
            <span class="c1">##########################</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_vectorize_edges</span><span class="p">(</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">new_node_name</span><span class="p">)</span>

            <span class="c1"># delete vectorized nodes from graph</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">new_node_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

        <span class="c1"># Third Stage: Finalize edge vectorization</span>
        <span class="c1">##########################################</span>

        <span class="c1"># go through nodes and create mapping for their inputs</span>
        <span class="k">for</span> <span class="n">node_name</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">node_name</span><span class="p">)</span>
            <span class="n">node_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sort_edges</span><span class="p">(</span><span class="n">node_inputs</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">)</span>

            <span class="c1"># loop over input variables of node</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">in_var</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node_inputs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>

                <span class="c1"># extract info for input variable connections</span>
                <span class="n">n_inputs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
                <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span> <span class="o">=</span> <span class="n">in_var</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)</span>
                <span class="n">delays</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="s1">&#39;delay&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">delays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">max_delay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">delays</span><span class="p">)</span> <span class="k">if</span> <span class="n">delays</span> <span class="k">else</span> <span class="kc">None</span>

                <span class="c1"># loop over different input sources</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">):</span>

                    <span class="k">if</span> <span class="n">max_delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                        <span class="c1"># add synaptic buffer to the input variable</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_buffer</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">buffer_length</span><span class="o">=</span><span class="n">max_delay</span><span class="p">,</span>
                                              <span class="n">edge</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

                    <span class="k">elif</span> <span class="n">n_inputs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

                        <span class="c1"># add synaptic input collector to the input variable</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge_input_collector</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="n">j</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">edges</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_vectorize_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">nodes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
                         <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combines all nodes in list to a single node and adds node to new net config.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nodes</span>
<span class="sd">            Names of the nodes to be combined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            name of the new node that was added to the net config.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_nodes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

        <span class="c1"># instantiate new node</span>
        <span class="c1">######################</span>

        <span class="n">node_ref</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">new_node</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node_ref</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">node_ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_ref</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># define new node&#39;s name</span>
        <span class="n">node_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">node_ref_tmp</span> <span class="o">=</span> <span class="n">node_ref</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;/&#39;</span><span class="ow">in</span> <span class="n">node_ref</span> <span class="k">else</span> <span class="n">node_ref</span>
        <span class="n">node_ref_tmp</span> <span class="o">=</span> <span class="n">node_ref_tmp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">node_ref_tmp</span> <span class="k">else</span> <span class="n">node_ref_tmp</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">node_ref_tmp</span> <span class="ow">in</span> <span class="n">node_name</span> <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]):</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{node_ref_tmp}</span><span class="s1">_all&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node_name</span> <span class="o">=</span> <span class="n">node_ref_tmp</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                <span class="n">n_tmp</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">n</span> <span class="k">else</span> <span class="n">n</span>
                <span class="n">n_tmp</span> <span class="o">=</span> <span class="n">n_tmp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">n_tmp</span> <span class="k">else</span> <span class="n">n_tmp</span>
                <span class="n">node_name</span> <span class="o">+=</span> <span class="n">f</span><span class="s1">&#39;_</span><span class="si">{n_tmp}</span><span class="s1">&#39;</span>
                <span class="n">test_names</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">test_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
                    <span class="n">test_name_tmp</span> <span class="o">=</span> <span class="n">test_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">test_name</span> <span class="k">else</span> <span class="n">test_name</span>
                    <span class="n">test_name_tmp</span> <span class="o">=</span> <span class="n">test_name_tmp</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">test_name_tmp</span> <span class="k">else</span> <span class="n">test_name_tmp</span>
                    <span class="n">test_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">test_name_tmp</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">([</span><span class="n">test_name</span> <span class="ow">in</span> <span class="n">node_name</span> <span class="k">for</span> <span class="n">test_name</span> <span class="ow">in</span> <span class="n">test_names</span><span class="p">]):</span>
                    <span class="k">break</span>
            <span class="n">node_name</span> <span class="o">+=</span> <span class="s1">&#39;_all&#39;</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{node_name}</span><span class="s2">.</span><span class="si">{node_idx}</span><span class="s2">&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">node_idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">node_name</span> <span class="o">+=</span> <span class="n">f</span><span class="s2">&quot;.</span><span class="si">{node_idx}</span><span class="s2">&quot;</span>
                <span class="k">break</span>

        <span class="c1"># add new node to net config</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="o">**</span><span class="n">new_node</span><span class="p">)</span>

        <span class="c1"># go through node attributes and store their value and shape</span>
        <span class="n">arg_vals</span><span class="p">,</span> <span class="n">arg_shapes</span> <span class="o">=</span> <span class="p">{},</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_ref</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

            <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_ref</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_ref</span><span class="p">][</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_ref</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="c1"># extract argument value and shape</span>
                <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;vtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;raw&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                        <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;Automatic optimization of the graph (i.e. method `vectorize` cannot be &quot;</span>
                                         <span class="n">f</span><span class="s2">&quot;applied to networks with variables of 2 or more dimensions. Variable &quot;</span>
                                         <span class="n">f</span><span class="s2">&quot;</span><span class="si">{arg_name}</span><span class="s2"> has shape </span><span class="si">{arg[&#39;shape&#39;]}</span><span class="s2">. Please turn of the `vectorize` option &quot;</span>
                                         <span class="n">f</span><span class="s2">&quot;or change the dimensionality of the argument.&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                            <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                        <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                        <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]]</span>
                        <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

                <span class="c1"># save index of original node&#39;s attributes in new nodes attributes</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_ref</span><span class="p">][</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># go through rest of the nodes and extract their argument shapes and values</span>
        <span class="c1">###########################################################################</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nodes</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="c1"># go through arguments</span>
            <span class="k">for</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">arg_vals</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                <span class="k">if</span> <span class="n">op_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">op_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                <span class="k">for</span> <span class="n">arg_name</span> <span class="ow">in</span> <span class="n">op</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                    <span class="n">arg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">op_name</span><span class="p">)</span>

                    <span class="c1"># extract value and shape of argument</span>
                    <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;vtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;raw&#39;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]):</span>
                                <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">val</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                                <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                            <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                            <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>

                    <span class="c1"># save index of original node&#39;s attributes in new nodes attributes</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># go through new arguments and update shape and values</span>
        <span class="k">for</span> <span class="n">op_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="s1">&#39;op_graph&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">arg_name</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_name</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="s1">&#39;value&#39;</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">arg</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;value&#39;</span><span class="p">:</span> <span class="n">arg_vals</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]})</span>
                <span class="k">if</span> <span class="s1">&#39;shape&#39;</span> <span class="ow">in</span> <span class="n">arg</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">arg</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s1">&#39;shape&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">n_nodes</span><span class="p">,)</span> <span class="o">+</span> <span class="n">arg_shapes</span><span class="p">[</span><span class="n">op_name</span><span class="p">][</span><span class="n">arg_name</span><span class="p">]})</span>

        <span class="k">return</span> <span class="n">node_name</span>

    <span class="k">def</span> <span class="nf">_vectorize_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Combines edges in list and adds a new edge to the new net config.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        source_name</span>
<span class="sd">            Name of the source node</span>
<span class="sd">        target_name</span>
<span class="sd">            Name of the target node</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get edges between source and target</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edges_between</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">target_name</span><span class="p">)</span>

        <span class="c1"># extract edges that connect the same variables on source and target</span>
        <span class="c1">####################################################################</span>

        <span class="k">while</span> <span class="n">edges</span><span class="p">:</span>

            <span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># get source and target variable</span>
            <span class="n">source_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span> <span class="s1">&#39;source_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">target_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span> <span class="s1">&#39;target_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># get edges with equal source and target variables between source and target node</span>
            <span class="n">edges_tmp</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span>
                                       <span class="s1">&#39;source_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="n">source_var</span> <span class="ow">and</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_attr</span><span class="p">(</span><span class="n">source_tmp</span><span class="p">,</span> <span class="n">target_tmp</span><span class="p">,</span> <span class="n">edge_tmp</span><span class="p">,</span>
                                            <span class="s1">&#39;target_var&#39;</span><span class="p">,</span> <span class="n">retrieve_from_node</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_var</span><span class="p">:</span>
                    <span class="n">edges_tmp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>

            <span class="c1"># vectorize those edges</span>
            <span class="c1">#######################</span>

            <span class="n">n_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_tmp</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_edges</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                <span class="c1"># go through edges and extract weight and delay</span>
                <span class="n">weight_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">delay_col</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_svar_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">old_tvar_idx</span> <span class="o">=</span> <span class="p">[]</span>

                <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">edges_tmp</span><span class="p">:</span>

                    <span class="n">weight</span><span class="p">,</span> <span class="n">delay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_conn</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

                    <span class="c1"># add weight, delay and variable indices to collector lists</span>
                    <span class="k">if</span> <span class="n">delay</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">delay_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">weight_col</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_var_idx</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_svar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>
                    <span class="n">idx_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_edge_var_idx</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="s1">&#39;target&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">idx_tmp</span><span class="p">:</span>
                        <span class="n">old_tvar_idx</span> <span class="o">+=</span> <span class="n">idx_tmp</span>

                <span class="c1"># create new, vectorized edge</span>
                <span class="c1">#############################</span>

                <span class="c1"># extract edge</span>
                <span class="n">edge_ref</span> <span class="o">=</span> <span class="n">edges_tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">new_edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge_ref</span><span class="p">]</span>

                <span class="c1"># change delay and weight attributes</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;delay&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">delay_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">delay_col</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">weight_col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">weight_col</span> <span class="k">else</span> <span class="kc">None</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;source_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_svar_idx</span>
                <span class="n">new_edge</span><span class="p">[</span><span class="s1">&#39;target_idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_tvar_idx</span>

                <span class="c1"># add new edge to new net config</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">net_config</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source_name</span><span class="p">,</span> <span class="n">target_name</span><span class="p">,</span> <span class="o">**</span><span class="n">new_edge</span><span class="p">)</span>

            <span class="c1"># delete vectorized edges from list</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges_tmp</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_vectorize_ops</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">op_key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                       <span class="n">nodes</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span>
                       <span class="n">new_node</span><span class="p">:</span> <span class="n">DiGraph</span><span class="p">,</span>
                       <span class="n">new_node_name</span><span class="p">:</span> <span class="nb">str</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Vectorize all instances of an operation across nodes and put them into a single-node backend.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        op_key</span>
<span class="sd">            Name of the operator that should be vectorized.</span>
<span class="sd">        nodes</span>
<span class="sd">            Collection of node names on which the operator exists.</span>
<span class="sd">        new_node</span>
<span class="sd">            Name of the new node that should be added to the graph.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># extract operation in question</span>
        <span class="n">node_name_tmp</span> <span class="o">=</span> <span class="n">nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">op_inputs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node_name_tmp</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="n">op_key</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node_name_tmp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">op_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># collect input dependencies of all nodes</span>
        <span class="c1">#########################################</span>

        <span class="n">nodes_tmp</span> <span class="o">=</span> <span class="p">[</span><span class="n">node_name_tmp</span><span class="p">]</span> <span class="o">+</span> <span class="n">nodes</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes_tmp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes_tmp</span><span class="p">:</span>
                <span class="n">op_inputs_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_node_attr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="n">op_key</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">op_inputs_tmp</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
                        <span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]]</span>
                        <span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]:</span>
                            <span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;sources&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;sources&#39;</span><span class="p">])</span>
                            <span class="n">op_inputs</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;reduce_dim&#39;</span><span class="p">])</span>

        <span class="c1"># extract operator-specific arguments and change their shape and value</span>
        <span class="c1">######################################################################</span>

        <span class="n">op_args</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name_tmp</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="s1">&#39;variables&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

            <span class="n">arg</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;vtype&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;raw&#39;</span><span class="p">:</span>

                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]))]</span>

                    <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">node_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">if</span> <span class="n">op_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="n">op_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                        <span class="n">new_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">)[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                        <span class="n">old_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                        <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_val</span><span class="p">)</span>

                        <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                                        <span class="p">(</span><span class="n">old_idx</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># add information to _net_config_map</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>
                    <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">)</span> <span class="o">+</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>

                <span class="c1"># go through nodes and extract shape and value information for arg</span>
                <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

                    <span class="k">for</span> <span class="n">node_name</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>

                        <span class="k">if</span> <span class="n">node_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                        <span class="k">if</span> <span class="n">op_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="n">op_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

                        <span class="c1"># extract node arg value and shape</span>
                        <span class="n">arg_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">arg_tmp</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                        <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">arg_tmp</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">])</span>

                        <span class="c1"># append value to argument dictionary</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">float</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_precision</span><span class="p">)</span> <span class="o">+</span> <span class="n">val</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">dims</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">idx_old</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">idx_old</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="n">idx_new</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx_old</span><span class="p">,</span> <span class="n">idx_new</span><span class="p">)</span>

                        <span class="c1"># add information to _net_config_map</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="c1"># add information to _net_config_map</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_net_config_map</span><span class="p">[</span><span class="n">node_name_tmp</span><span class="p">][</span><span class="n">op_key</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_node_name</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
                                                                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>

                <span class="c1"># change shape of argument</span>
                <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span><span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>

                <span class="c1"># add argument to new node&#39;s argument dictionary</span>
                <span class="n">op_args</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg</span>

        <span class="c1"># add operator to node</span>
        <span class="n">new_node</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">op_key</span><span class="p">,</span>
                          <span class="n">operator</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_op_attr</span><span class="p">(</span><span class="n">node_name_tmp</span><span class="p">,</span> <span class="n">op_key</span><span class="p">,</span> <span class="s1">&#39;operator&#39;</span><span class="p">),</span>
                          <span class="n">variables</span><span class="o">=</span><span class="n">op_args</span><span class="p">)</span></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../../contents.html">
    <img class="logo" src="../../../_static/PyRates_logo_color.png" alt="Logo"/>
    
    <h1 class="logo logo-name">PyRates</h1>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=pyrates-neuroscience&repo=PyRates&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/pyrates-neuroscience/PyRates">
    <img
        alt="https://secure.travis-ci.org/pyrates-neuroscience/PyRates.svg?branch=master"
        src="https://secure.travis-ci.org/pyrates-neuroscience/PyRates.svg?branch=master"
    />
</a>
</p>



<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Richard Gast, Daniel Rose, Christoph Salomon.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>